import numpy as np
from bisect import bisect_left
from scipy.special import erf


from ..methods.base_classes import Image, Cube, Region, Point, Contours
from ..methods.filters import map_filter_names, nice_filter_names, default_plot_scale_lims, default_plot_units, default_cmaps


import numpy as np
from scipy.interpolate import RegularGridInterpolator
import itertools







def load_nebular_tables(self,wl,resolution,emimetal,emimodel):
    """
    Load and process precomputed nebular emission line tables from Byler et al. models.

    This function reads tabulated emission line luminosities (in erg/s per ionizing photon)
    for a given metallicity and emission model (2017 or 2018), and convolves the lines with
    the desired spectral resolution and wavelength grid. The resulting emission line spectra 
    are suitable for adding to stellar SEDs generated by codes like CIGALE.

    The lines are modeled as Gaussians, and the convolution simulates how they would appear
    in an observed spectrum, taking into account the resolution and pixel binning. An 
    interpolation function is returned, allowing the user to compute the full nebular 
    emission spectrum for any given ionization parameter and stellar population age.

    Parameters:
        wl (ndarray): Wavelength array in Angstroms.
        resolution (ndarray): Spectral resolution (R = λ/Δλ) array matching `wl`.
        emimetal (float): Metallicity of the model to load (closest available will be used).
        emimodel (str): Emission line model version ('2017' or '2018').

    Returns:
        nebular_emission_spectrum (function): Callable(ion, age) → emission spectrum on wl grid.
        emm_ions (ndarray): Ionization parameter grid points used in the model.
        emm_ages (ndarray): Age grid points (in Myr) used in the model.
    """
    
    wl_lyman = 912.
    ilyman = np.searchsorted(wl, wl_lyman, side='left') #wavelength just above Lyman limit
    lycont_wls = np.r_[wl[:ilyman], np.array([wl_lyman])]
    clyman_young = None #A list of two elements, first is for phot, the other for spec
    clyman_old   = None #A list of two elements, first is for phot, the other for spec

    # Emission line wavelengths have to be in VACUUM
    
    if emimodel == '2018':
        byler_bins = [382,9,7]
        byler_fname = 'nebular_Byler_mist_2018.lines'
        metallist = np.array([6.3245e-05,2.0000e-04,3.5565e-04,6.3245e-04,1.1246e-03,2.0000e-03,3.5565e-03,6.3245e-03,1.1246e-02,2.000e-02,3.5565e-02,6.3245e-02])
        metalstrg = np.array(['-2.5000e+00','-2.0000e+00','-1.7500e+00','-1.5000e+00','-1.2500e+00','-1.0000e+00','-7.5000e-01','-5.0000e-01','-2.5000e-01','0.0000e+00','2.5000e-01','5.0000e-01'])
    else:
        byler_bins = [128,10,7]
        byler_fname = 'nebular_Byler_mist_2017.lines'
        metallist = np.array([0.00020,0.00063246,0.00209426,0.00526054,0.00814761,0.01002374,0.01261915,0.01588656,0.02,0.02517851,0.03169786])
        metalstrg = np.array(['-1.9800e+00','-1.5000e+00','-9.8000e-01','-5.8000e-01','-3.9000e-01','-3.0000e-01','-2.0000e-01','-1.0000e-01','0.0000e+00','1.0000e-01','2.0000e-01'])
    
    print("Loading nebular lines templates from ",byler_fname)

    emm_scales = np.zeros((byler_bins[2],byler_bins[1],byler_bins[0]), dtype=float)
    emm_wls    = np.zeros(byler_bins[0],        dtype=float)
    emm_ages   = np.zeros(byler_bins[1],        dtype=float)
    emm_ions   = np.zeros(byler_bins[2],        dtype=float)
    icnt = 0
    rline = 0
    iline = 0
    
    
    metind = np.argmin(np.abs(metallist-emimetal))  # Select the closest metallicity available
    print(' Emission line metallicity requested {}, found {:5.4f}'.format(emimetal,metallist[metind]))
    emimetal = metallist[metind]

    print(f"Tabulated values for ionized gas age (Myr): {emm_ages}")
    print(f"Tabulated values for ionization coefficient: {emm_ions}")

    # load emission lines tables
    with open('../Pangal/data/'+byler_fname,'r') as file:
        
        for line in file:
            if line[0] != '#':
                temp = (line.strip()).split(None)
                if not iline: #Read wave line
                    emm_wls[:] = np.array(temp, dtype=float)
                    iline = 1
                else:
                    if rline: #Read line fluxes
                        emm_scales[icnt%7,icnt//7,:] = np.array(temp, dtype=float)*3.839e33 #erg/s #output should be in erg/s/QHO
                        icnt += 1
                    if len(temp) == 3 and temp[0] == metalstrg[metind]:
                        rline = 1
                        emm_ages[icnt//7] = float(temp[1])/1e6
                        emm_ions[icnt%7]  = float(temp[2])
                    else:
                        rline = 0

    # Filters out non-physical or extremely high wavelengths ?? Why ??
    keep_scale = (emm_wls<1E5)        
    emm_scales = emm_scales[:,:,keep_scale]
    emm_wls    = emm_wls[keep_scale]

    # Convolve lines to model resolution
    # Emission lines are modeled as Gaussians centered at their rest wavelengths.
    # To add these lines realistically, you integrate the Gaussian emission line profile over each pixel's wavelength bin.
    # Simulates how nebular emission lines would appear in a spectrum observed at a given resolution and wavelength sampling
    
    dpix = np.diff(wl)
    wl_edges  = np.r_[np.array([wl[0]-dpix[0]/2.]), np.r_[wl[1:]-dpix/2., np.array([wl[-1]+dpix[-1]/2.])]]
    res_lines = np.interp(emm_wls, wl, resolution)/2.355
    

    emm_lines_all = np.zeros((len(emm_ions), len(emm_ages), len(wl)), dtype=float)

    for jj in range(len(emm_ions)):
        for ii in range(len(emm_ages)):
            this_scale = emm_scales[jj,ii,:]
            emm_lines_all[jj,ii,:] = np.sum(this_scale[:,None]*\
                np.diff(0.5*(1.+erf((wl_edges[None,:]-emm_wls[:,None])/\
                np.sqrt(2.*res_lines**2)[:,None])), axis=1)/np.diff(wl_edges), axis=0)


    # Create interpolator: maps (ion, age) -> spectrum on wl grid
    interp_func = RegularGridInterpolator(
        points=(emm_ions, emm_ages),  # shape (n_ions, n_ages)
        values=emm_lines_all,         # shape (n_ions, n_ages, n_wl)
        bounds_error=False,
        fill_value=0.0
    )

    # Define a function for convenience
    def nebular_emission_spectrum(ion, age):
        input_point = np.array([[ion, age]])  # shape (1, 2)
        return interp_func(input_point)[0]    # returns (n_wl,)
    
    print("Loading of nebular lines templates completed.")
    
    return nebular_emission_spectrum, emm_ions, emm_ages




def load_dust_emission_models(self,wl,dustemimodel):
    """
    Returns dust emission templates from Dale & Helou 2002 (dustemimodel = 'dh02')
    or from Draine & Li 2014 (dustemimodel = 'dl14')
    takes in input a sps model wl array (extended on all IR band)
    Returns a list of dust emission spectra INTERPOLATED on sps model wl, one for each alpha, and the list of alpha
    """

    #first fetch alpha values
    print("Loading dust emission templates from: alpha_{}.dat".format(dustemimodel))
 
    dh_alpha = np.loadtxt('../data/alpha_{}.dat'.format(dustemimodel), usecols=(0,))

    print("Tabulated alpha values: ",dh_alpha)

    
    dh_wl = np.loadtxt('../data/spectra_{}.dat'.format(dustemimodel), usecols=(0,))*1e4

    dh_dustemm = np.zeros((len(dh_alpha), len(wl)), dtype=float)
    
    for ii in range(len(dh_alpha)):
        
        tdust = 10**np.loadtxt('../data/spectra_{}.dat'.format(dustemimodel), usecols=(ii+1,))
        #tdust[dh_wl<5e4] = 0.
        #Interpolate the models in nu*fnu to the final wave grid, then divide by wave to get flambda
        dh_dustemm[ii,:] = np.interp(wl, dh_wl, tdust)/wl

        #normalize to Lbol = 1
        norm = np.trapz(dh_dustemm, wl)
        dh_dustemm /= norm[:,None]

    print("Loading of dust emission templates completed.")

    return dh_dustemm, dh_alpha





def model_grid_interpolator(self, model_list, param_names, extra_pars_to_interpolate=None):
    """
    Build N-dimensional interpolators for young and old fluxes.

    Parameters:
        model_list (list): Flat list of Spectrum models, each with `.flux_young`, `.flux_old`, `.header`
        param_names (list of str): Names of parameters to define the grid (e.g. ['age', 'tau'])

    Returns:
        interp_flux_young: Callable f(**params) -> flux_young (shape: n_wl)
        interp_flux_old: Callable f(**params) -> flux_old (shape: n_wl)
        grid_axes: List of sorted arrays for each parameter axis
        wl: Wavelength array (from first model)
    """

    # Step 1: Build param space
    param_tuples = []
    param_to_model = {}
    for model in model_list:
        try:
            values = tuple(model.header[k] for k in param_names)
        except KeyError as e:
            raise KeyError(f"Model is missing parameter {e} in header.")
        param_tuples.append(values)
        param_to_model[values] = model

    # Step 2: Build grid axes
    grid_axes = [np.array(sorted(set(p[i] for p in param_tuples))) for i in range(len(param_names))]

    # Step 3: Allocate grids for young and old fluxes
    grid_shape = tuple(len(ax) for ax in grid_axes)
    n_wl = model_list[0].flux_young.size

    flux_young_grid = np.zeros(grid_shape + (n_wl,))
    flux_old_grid = np.zeros(grid_shape + (n_wl,))

    # Step 4: Fill the grids
    for idxs in np.ndindex(*grid_shape):
        key = tuple(grid_axes[i][idxs[i]] for i in range(len(grid_axes)))
        model = param_to_model[key]
        flux_young_grid[idxs] = model.flux_young
        flux_old_grid[idxs] = model.flux_old

    # Step 5: Build interpolators
    interp_young = RegularGridInterpolator(points=grid_axes, values=flux_young_grid, bounds_error=False, fill_value=None)
    interp_old = RegularGridInterpolator(points=grid_axes, values=flux_old_grid, bounds_error=False, fill_value=None)

    def interp_flux_young(**kwargs):
        x = [kwargs[name] for name in param_names]
        return interp_young(x)[0]

    def interp_flux_old(**kwargs):
        x = [kwargs[name] for name in param_names]
        return interp_old(x)[0]
    
    return interp_flux_young, interp_flux_old, grid_axes, model_list[0].wl






















# Dust attenuation curve based on Calzetti et al. (2000) law
# Takes in imput an array of wavelengths and returns the attenuation function

def dust_attenuation_curve(wl, leitatt, uv_bump):
    
    k_cal = np.zeros(len(wl), dtype=float)  # cal for Calzetti

    #compute attenuation assuming Calzetti+ 2000 law
    #single component 

    R = 4.05
    div = wl.searchsorted(6300., side='left')
    
    #Longer than 6300
    k_cal[div:] = 2.659*( -1.857 + 1.04*(1e4/wl[div:])) + R
    #Shorter than 6300
    k_cal[:div] = 2.659*(-2.156 + 1.509*(1e4/wl[:div]) - 0.198*(1e4/wl[:div])**2 + 0.011*(1e4/wl[:div])**3) + R
    

    #IF REQUESTED Use leiterer 2002 formula below 1500A
    if leitatt:
        div = wl.searchsorted(1500., side='left')
        #Shorter than 1500
        k_cal[:div] = (5.472 + 0.671e4 / wl[:div] - 9.218e5 / wl[:div] ** 2 + 2.620e9 / wl[:div] ** 3)

    #Prevents negative attenuation, which can arise from extrapolation or math artifacts
    zero = bisect_left(-k_cal, 0.)
    k_cal[zero:] = 0.

    #2175A bump
    if uv_bump:
        eb = 1.0
        k_bump = np.zeros(len(wl), dtype=float)
        k_bump[:] = eb*(wl*350)**2 / ((wl**2 - 2175.**2)**2 + (wl*350)**2)
        k_cal += k_bump

            
    return 0.4 * k_cal / R



def vactoair(wl):
    """Convert vacuum wavelengths to air wavelengths using the conversion
    given by Morton (1991, ApJS, 77, 119).

    """
    wave2 = np.asarray(wl, dtype=float)**2
    fact = 1. + 2.735182e-4 + 131.4182/wave2 + 2.76249e8/(wave2*wave2)
    return wl/fact


def airtovac(wl):
    """Convert air wavelengths to vacuum wavelengths using the conversion
    given by Morton (1991, ApJS, 77, 119).

    """
    sigma2 = np.asarray(1E4/wl, dtype=float)**2
    
    fact = 1. + 6.4328e-5 + 2.949281e-2/(146.-sigma2) + 2.5540e-4/(41.-sigma2)
    fact[wl < 2000] = 1.0
    
    return wl*fact
