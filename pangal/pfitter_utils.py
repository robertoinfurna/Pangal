
import numpy as np
import astropy
from bisect import bisect_left
from scipy.special import erf
from scipy.interpolate import RegularGridInterpolator
import itertools
import os

from dynesty import NestedSampler

import sys, os
sys.path.append(os.path.expanduser('~/Desktop/Pangal'))

from .image import Image
from .spectrum import Spectrum
from .filters import Filter, map_filter_names, nice_filter_names, default_plot_scale_lims, default_plot_units, default_cmaps


import numpy as np
import astropy
from bisect import bisect_left
from scipy.special import erf
from scipy.interpolate import RegularGridInterpolator, interp1d
import itertools
import os


# UTILS
# Base directory containing the “DISKEVOL.RES_L0.05_V*” files
this_dir = os.path.dirname(os.path.abspath(__file__))

# Construct full path to the data directory
data_dir = os.path.join(this_dir, ".", "data")
data_dir = os.path.normpath(data_dir)



def load_nebular_tables(self,wl,resolution,emimetal,emimodel):
    """
    Load and process precomputed nebular emission line tables from Byler et al. models.

    This function reads tabulated emission line luminosities (in erg/s per ionizing photon)
    for a given metallicity and emission model (2017 or 2018), and convolves the lines with
    the desired spectral resolution and wavelength grid. The resulting emission line spectra 
    are suitable for adding to stellar SEDs generated by codes like CIGALE.

    The lines are modeled as Gaussians, and the convolution simulates how they would appear
    in an observed spectrum, taking into account the resolution and pixel binning. An 
    interpolation function is returned, allowing the user to compute the full nebular 
    emission spectrum for any given ionization parameter and stellar population age.

    Parameters:
        wl (ndarray): Wavelength array in Angstroms.
        resolution (ndarray): Spectral resolution (R = λ/Δλ) array matching `wl`.
        emimetal (float): Metallicity of the model to load (closest available will be used).
        emimodel (str): Emission line model version ('2017' or '2018').

    Returns:
        nebular_emission_spectrum (function): Callable(ion, age) → emission spectrum on wl grid.
        emm_ions (ndarray): Ionization parameter grid points used in the model.
        emm_ages (ndarray): Age grid points (in Myr) used in the model.
    """
    
    wl_lyman = 912.
    ilyman = np.searchsorted(wl, wl_lyman, side='left') #wavelength just above Lyman limit
    lycont_wls = np.r_[wl[:ilyman], np.array([wl_lyman])]
    clyman_young = None #A list of two elements, first is for phot, the other for spec
    clyman_old   = None #A list of two elements, first is for phot, the other for spec

    # Emission line wavelengths have to be in VACUUM
    
    if emimodel == '2018':
        byler_bins = [382,9,7]
        byler_fname = 'nebular_Byler_mist_2018.lines'
        metallist = np.array([6.3245e-05,2.0000e-04,3.5565e-04,6.3245e-04,1.1246e-03,2.0000e-03,3.5565e-03,6.3245e-03,1.1246e-02,2.000e-02,3.5565e-02,6.3245e-02])
        metalstrg = np.array(['-2.5000e+00','-2.0000e+00','-1.7500e+00','-1.5000e+00','-1.2500e+00','-1.0000e+00','-7.5000e-01','-5.0000e-01','-2.5000e-01','0.0000e+00','2.5000e-01','5.0000e-01'])
    else:
        byler_bins = [128,10,7]
        byler_fname = 'nebular_Byler_mist_2017.lines'
        metallist = np.array([0.00020,0.00063246,0.00209426,0.00526054,0.00814761,0.01002374,0.01261915,0.01588656,0.02,0.02517851,0.03169786])
        metalstrg = np.array(['-1.9800e+00','-1.5000e+00','-9.8000e-01','-5.8000e-01','-3.9000e-01','-3.0000e-01','-2.0000e-01','-1.0000e-01','0.0000e+00','1.0000e-01','2.0000e-01'])
    
    print("Loading nebular lines templates from ",byler_fname)

    emm_scales = np.zeros((byler_bins[2],byler_bins[1],byler_bins[0]), dtype=float)
    emm_wls    = np.zeros(byler_bins[0],        dtype=float)
    emm_ages   = np.zeros(byler_bins[1],        dtype=float)
    emm_ions   = np.zeros(byler_bins[2],        dtype=float)
    icnt = 0
    rline = 0
    iline = 0
    
    
    metind = np.argmin(np.abs(metallist-emimetal))  # Select the closest metallicity available
    print(' Emission line metallicity requested {}, found {:5.4f}'.format(emimetal,metallist[metind]))
    emimetal = metallist[metind]


    # load emission lines tables
    file_path = os.path.join(data_dir, byler_fname)

    with open(file_path, 'r') as file:
        
        for line in file:
            if line[0] != '#':
                temp = (line.strip()).split(None)
                if not iline: #Read wave line
                    emm_wls[:] = np.array(temp, dtype=float)
                    iline = 1
                else:
                    if rline: #Read line fluxes
                        emm_scales[icnt%7,icnt//7,:] = np.array(temp, dtype=float)*3.839e33 #erg/s #output should be in erg/s/QHO
                        icnt += 1
                    if len(temp) == 3 and temp[0] == metalstrg[metind]:
                        rline = 1
                        emm_ages[icnt//7] = float(temp[1])/1e6
                        emm_ions[icnt%7]  = float(temp[2])
                    else:
                        rline = 0


    print(f"Tabulated values for ionized gas age (Myr): {emm_ages}")
    print(f"Tabulated values for ionization coefficient: {emm_ions}")

    # Filters out non-physical or extremely high wavelengths ?? Why ??
    keep_scale = (emm_wls<1E5)        
    emm_scales = emm_scales[:,:,keep_scale]
    emm_wls    = emm_wls[keep_scale]

    # Convolve lines to model resolution
    # Emission lines are modeled as Gaussians centered at their rest wavelengths.
    # To add these lines realistically, you integrate the Gaussian emission line profile over each pixel's wavelength bin.
    # Simulates how nebular emission lines would appear in a spectrum observed at a given resolution and wavelength sampling
    
    dpix = np.diff(wl)
    wl_edges  = np.r_[np.array([wl[0]-dpix[0]/2.]), np.r_[wl[1:]-dpix/2., np.array([wl[-1]+dpix[-1]/2.])]]
    delta_lambda = wl/resolution
    res_lines = np.interp(emm_wls, wl,delta_lambda)/2.355
    

    emm_lines_all = np.zeros((len(emm_ions), len(emm_ages), len(wl)), dtype=float)

    for jj in range(len(emm_ions)):
        for ii in range(len(emm_ages)):
            this_scale = emm_scales[jj,ii,:]
            emm_lines_all[jj,ii,:] = np.sum(this_scale[:,None]*\
                np.diff(0.5*(1.+erf((wl_edges[None,:]-emm_wls[:,None])/\
                np.sqrt(2.*res_lines**2)[:,None])), axis=1)/np.diff(wl_edges), axis=0)


    # Create interpolator: maps (ion, age) -> spectrum on wl grid
    interp_func = RegularGridInterpolator(
        points=(emm_ions, emm_ages),  # shape (n_ions, n_ages)
        values=emm_lines_all,         # shape (n_ions, n_ages, n_wl)
        bounds_error=False,
        fill_value=0.0
    )

    # Define a function for convenience
    def nebular_emission_spectrum(ion, age):
        input_point = np.array([[ion, age]])  # shape (1, 2)
        return interp_func(input_point)[0]    # returns (n_wl,)
    
    print("Loading of nebular lines templates completed.")
    
    return nebular_emission_spectrum, emm_ions, emm_ages



def load_dust_emission_models(self, wl, dustemimodel):
    """
    Loads dust emission templates from Dale & Helou 2002 (dustemimodel = 'dh02') and return a function of alpha
    or Draine & Li 2014 (dustemimodel = 'dl14'), interpolated on the input wavelength grid.
    """

    alpha_file = os.path.join(data_dir, f'alpha_{dustemimodel}.dat')
    spectra_file = os.path.join(data_dir, f'spectra_{dustemimodel}.dat')

    # Check files exist
    if not os.path.exists(alpha_file):
        raise FileNotFoundError(f"Missing file: {alpha_file}")
    if not os.path.exists(spectra_file):
        raise FileNotFoundError(f"Missing file: {spectra_file}")

    #print(f"Loading dust emission templates from: {alpha_file}")

    # Load alpha values and spectra
    dustem_alpha = np.loadtxt(alpha_file, usecols=(0,))
    dustem_wl = np.loadtxt(spectra_file, usecols=(0,)) * 1e4  # assuming microns to Angstroms
    full_spectra = np.loadtxt(spectra_file)

    # Initialize template matrix
    tdustem = np.zeros((len(dustem_alpha), len(wl)), dtype=float)

    for ii in range(len(dustem_alpha)):
        tdust = 10 ** full_spectra[:, ii + 1]  # column 1 is wavelength, so ii+1
        tdustem[ii, :] = np.interp(wl, dustem_wl, tdust, left=0.0, right=0.0) / wl

    # Normalize each template to Lbol = 1
    norm = np.trapz(tdustem, wl, axis=1)
    tdustem /= norm[:, None]

    dustem_func = interp1d(dustem_alpha, tdustem, axis=0, bounds_error=True)

    # Define a function for convenience
    def dust_emission_spectrum(alpha):
        return dustem_func(alpha)

    print(f"Tabulated alpha values from 'alpha_{dustemimodel}.dat': {dustem_alpha}")
    print("Loading of dust emission templates completed.")

    return dust_emission_spectrum, dustem_alpha




def model_grid_interpolator(self, model_list, param_names, extra_pars_to_interpolate=None):
    """
    Build N-dimensional interpolators for young and old fluxes.

    Parameters:
        model_list (list): Flat list of Spectrum models, each with `.flux_young`, `.flux_old`, `.header`
        param_names (list of str): Names of parameters to define the grid (e.g. ['age', 'tau'])

    Returns:
        interp_flux_young: Callable f(**params) -> flux_young (shape: n_wl)
        interp_flux_old: Callable f(**params) -> flux_old (shape: n_wl)
        grid_axes: List of sorted arrays for each parameter axis
        wl: Wavelength array (from first model)
    """

    # Step 1: Build param space
    param_tuples = []
    param_to_model = {}
    for model in model_list:
        try:
            values = tuple(model.header[k] for k in param_names)
        except KeyError as e:
            raise KeyError(f"Model is missing parameter {e} in header.")
        param_tuples.append(values)
        param_to_model[values] = model

    # Step 2: Build grid axes
    grid_axes = [np.array(sorted(set(p[i] for p in param_tuples))) for i in range(len(param_names))]

    # Step 3: Allocate grids for young and old fluxes
    grid_shape = tuple(len(ax) for ax in grid_axes)
    n_wl = model_list[0].flux_young.size

    flux_young_grid = np.zeros(grid_shape + (n_wl,))
    flux_old_grid = np.zeros(grid_shape + (n_wl,))

    # Step 4: Fill the grids
    for idxs in np.ndindex(*grid_shape):
        key = tuple(grid_axes[i][idxs[i]] for i in range(len(grid_axes)))
        model = param_to_model[key]
        flux_young_grid[idxs] = model.flux_young
        flux_old_grid[idxs] = model.flux_old

    # Step 5: Build interpolators
    interp_young = RegularGridInterpolator(points=grid_axes, values=flux_young_grid, bounds_error=False, fill_value=None)
    interp_old = RegularGridInterpolator(points=grid_axes, values=flux_old_grid, bounds_error=False, fill_value=None)

    def interp_flux_young(**kwargs):
        x = [kwargs[name] for name in param_names]
        return interp_young(x)[0]

    def interp_flux_old(**kwargs):
        x = [kwargs[name] for name in param_names]
        return interp_old(x)[0]
    
    return interp_flux_young, interp_flux_old, grid_axes, model_list[0].wl






















# Dust attenuation curve based on Calzetti et al. (2000) law
# Takes in imput an array of wavelengths and returns the attenuation function

def dust_attenuation_curve(wl, leitatt, uv_bump):
    
    k_cal = np.zeros(len(wl), dtype=float)  # cal for Calzetti

    #compute attenuation assuming Calzetti+ 2000 law
    #single component 

    R = 4.05
    div = wl.searchsorted(6300., side='left')
    
    #Longer than 6300
    k_cal[div:] = 2.659*( -1.857 + 1.04*(1e4/wl[div:])) + R
    #Shorter than 6300
    k_cal[:div] = 2.659*(-2.156 + 1.509*(1e4/wl[:div]) - 0.198*(1e4/wl[:div])**2 + 0.011*(1e4/wl[:div])**3) + R
    

    #IF REQUESTED Use leitherer 2002 formula below 1500A
    if leitatt:
        div = wl.searchsorted(1500., side='left')
        #Shorter than 1500
        k_cal[:div] = (5.472 + 0.671e4 / wl[:div] - 9.218e5 / wl[:div] ** 2 + 2.620e9 / wl[:div] ** 3)

    #Prevents negative attenuation, which can arise from extrapolation or math artifacts
    zero = bisect_left(-k_cal, 0.)
    k_cal[zero:] = 0.

    #2175A bump
    if uv_bump:
        eb = 1.0
        k_bump = np.zeros(len(wl), dtype=float)
        k_bump[:] = eb*(wl*350)**2 / ((wl**2 - 2175.**2)**2 + (wl*350)**2)
        k_cal += k_bump

            
    return 0.4 * k_cal / R





def vactoair(wl):
    """Convert vacuum wavelengths to air wavelengths using the conversion
    given by Morton (1991, ApJS, 77, 119).

    """
    wave2 = np.asarray(wl, dtype=float)**2
    fact = 1. + 2.735182e-4 + 131.4182/wave2 + 2.76249e8/(wave2*wave2)
    return wl/fact


def airtovac(wl):
    """Convert air wavelengths to vacuum wavelengths using the conversion
    given by Morton (1991, ApJS, 77, 119).

    """
    sigma2 = np.asarray(1E4/wl, dtype=float)**2
    
    fact = 1. + 6.4328e-5 + 2.949281e-2/(146.-sigma2) + 2.5540e-4/(41.-sigma2)
    fact[wl < 2000] = 1.0
    
    return wl*fact


    